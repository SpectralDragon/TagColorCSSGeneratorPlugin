import Foundation
import Publish
import PublishColorUtils

public extension Plugin {
    
    /// Check that tag is available and can be colored.
    static func checkTagsAvailability<T: RawRepresentable & CaseIterable>(_ value: T.Type) -> Self where T.RawValue == String {
        Plugin(name: "CheckTagsAvailability", installer: { context in
            let notExistsTags = context.allTags
                .filter { tag in return !value.allCases.contains(where: { $0.rawValue == tag.string }) }
                .map { $0.string }
            
            if !notExistsTags.isEmpty {
                
                let brokenArticles = context.allItems(sortedBy: \.date)
                    .filter {
                        $0.tags.contains(where: { tag in notExistsTags.contains(tag.string)
                    })}
                
                let errorMessage = brokenArticles.reduce("", { result, item in
                    
                    let tags = item.tags.map { $0.string }.filter { notExistsTags.contains($0) }.joined(separator: " ")
                    
                    let new = result + "`\(tags)` in article at path: \(item.path)\n"
                    return new
                })
                
                fatalError("Found an unavailable tags:\n\(errorMessage)")
            }
        })
    }
    
    private static func createTagStyle(_ className: String, color: Color) -> String {
        """
        .\(className) {
        \tbackground-color: \(color.opacity(0.4).hexWithAlpha);
        \tcolor: \(color.hexWithAlpha);
        \tfont-weight: bold;
        }
        
        .\(className):hover {
        \tbackground-color: \(color.opacity(0.7).hexWithAlpha);
        }
        """
    }
    
    static func tagColorCSSGenerator(
        tagsCSSPrefix: String = "",
        resourcePath: Path = "Resources",
        tagsFileName: String = "tags.css",
        builder: @escaping (Tag) -> Color
    ) -> Self {
        
        Plugin(name: "TagColorCSSGenerator") { context in
            
            let tuple = context.allTags.map { tag -> (light: String, dark: String?) in
                
                let color = builder(tag)
                let className = "\(tagsCSSPrefix)\(tag.normalizedString())"
                
                
                let lightStyle = Self.createTagStyle(className, color: color)
                let darkStyle = color.dark.flatMap { Self.createTagStyle(className, color: $0) }
                
                Tag.styles[tag] = className
                
                return (lightStyle, darkStyle)
            }
            
            if let folder = try? context.folder(at: resourcePath) {
                if folder.containsFile(named: tagsFileName) {
                    try folder.file(at: tagsFileName).delete()
                }
                
                let tagsFile = try folder.createFile(at: tagsFileName)
                
                var content = """
                /* THIS FILE WAS AUTO GENERATED. DO NOT CHANGE IT MANUAL */
                /* Generated by `TagColorCSSGeneratorPlugin` https://github.com/SpectralDragon/TagColorCSSGeneratorPlugin */

                \(tuple.map { $0.light }.joined(separator: "\n\n"))
                """
                
                let stylesForDark = tuple.compactMap { $0.dark }
                
                if !stylesForDark.isEmpty {
                    content.append("\n\n@media(prefers-color-scheme: dark) {\n\n")
                    
                    for darkStyle in stylesForDark {
                        let style = darkStyle.replacingOccurrences(of: "\n", with: "\n\t")
                        content.append("\t\(style)\n\n")
                    }
                    content.append("}")
                }
                
                try tagsFile.write(content)
            }
        }
    }
}

public extension Tag {
    
    internal static var styles: [Tag: String] = [:]
    
    var cssClass: String {
        return Self.styles[self] ?? ""
    }
}
